<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GitHub Secret Scanner — Your Repos Only (Local)</title>
  <style>
    :root { --bg:#0b1320; --panel:#121a2a; --muted:#90a4c4; --text:#e6edf3; --accent:#7aa2ff; --danger:#ff6b6b; }
    html,body{ height:100%; }
    body{ margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; background:linear-gradient(180deg,var(--bg),#0f172a 70%); color:var(--text);} 
    header{ padding:24px 16px 8px; text-align:center; }
    header h1{ margin:0 0 6px; }
    header p{ margin:0; color:var(--muted); }
    .container{ max-width:1100px; margin:18px auto 64px; padding:0 16px; }
    .panel{ background:var(--panel); border:1px solid rgba(255,255,255,0.06); border-radius:14px; padding:16px; box-shadow:0 8px 30px rgba(0,0,0,0.35); }
    .grid{ display:grid; gap:12px; }
    @media(min-width: 980px){ .grid-cols-2{ grid-template-columns: 1.4fr 1fr; } }
    label{ display:block; font-size:13px; color:var(--muted); margin-bottom:6px; }
    input[type=text],input[type=password],textarea{ width:100%; background:#0f1627; color:var(--text); border:1px solid rgba(255,255,255,0.08); border-radius:10px; padding:10px 12px; box-sizing:border-box; outline:none; }
    .row{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .row>*{ flex:1 1 200px; }
    .btn{ background:#19233a; color:var(--text); border:1px solid rgba(255,255,255,0.08); padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:600; }
    .btn.primary{ background:var(--accent); color:#0b1020; border-color:transparent; }
    .btn.danger{ background:var(--danger); color:#0b1020; border-color:transparent; }
    .btn:disabled{ opacity:.55; cursor:not-allowed; }
    .help{ color:var(--muted); font-size:13px; }
    .status{ display:grid; grid-template-columns: repeat(4, minmax(120px,1fr)); gap:10px; margin-top:10px; }
    .stat{ background:#0e1526; border:1px solid rgba(255,255,255,0.06); border-radius:10px; padding:10px; }
    .stat .label{ color:var(--muted); font-size:12px; }
    .stat .val{ font-size:18px; font-weight:700; }
    .progressbar{ height:10px; background:rgba(255,255,255,0.07); border-radius:999px; overflow:hidden; }
    .progressbar>div{ height:100%; width:0%; background:linear-gradient(90deg,var(--accent),#76e3ff); transition:width .2s ease; }
    .results{ margin-top:18px; }
    .match{ background:#0e1526; border:1px solid rgba(255,255,255,0.08); border-radius:12px; padding:12px; margin-bottom:12px; }
    .match .hdr{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .badge{ font-size:12px; padding:2px 8px; border-radius:999px; background:#1b2642; border:1px solid rgba(255,255,255,0.08); color:#b9c7f6; }
    .badge.warn{ background:#3b2c14; color:#ffd591; }
    .badge.crit{ background:#3b1919; color:#ffb3b3; }
    pre{ white-space:pre-wrap; background:#0b1020; border-radius:10px; padding:10px; border:1px solid rgba(255,255,255,0.06); }
    .footer-note{ margin-top:12px; color:var(--muted); font-size:12px; }
  </style>
</head>
<body>
  <header>
    <h1>GitHub Secret Scanner</h1>
    <p>Local, browser-only utility to scan <strong>your own repositories</strong> for accidental credentials. Token optional (public-only mode).</p>
  </header>

  <div class="container grid grid-cols-2">
    <section class="panel">
      <h2>Setup</h2>
      <div class="grid">
        <div>
          <label>GitHub Personal Access Token (optional; required for private repos & higher limits)</label>
          <input id="token" type="password" autocomplete="off" placeholder="ghp_... or github_pat_...">
          <div class="help">With token: scans private + public, higher rate limits. Without token: scans public repos only (rate limit ~60/hr).</div>
        </div>
        <div class="row">
          <div>
            <label>Target GitHub username</label>
            <input id="username" type="text" placeholder="your-github-handle" required>
          </div>
          <div>
            <label>Max file size (KB)</label>
            <input id="maxSizeKB" type="text" value="512">
          </div>
        </div>
        <div class="row">
          <label style="flex:0 0 auto"><input id="includePrivate" type="checkbox" checked> Include private repos (requires token)</label>
          <label style="flex:0 0 auto"><input id="includeForks" type="checkbox"> Include forks</label>
          <label style="flex:0 0 auto"><input id="includeArchived" type="checkbox"> Include archived</label>
          <label style="flex:0 0 auto"><input id="respectGitignore" type="checkbox" checked> Skip common build/vendor dirs</label>
        </div>
        <div class="row">
          <label style="flex:0 0 auto"><input id="scanHistory" type="checkbox"> Scan commit history (default branch)</label>
          <div style="flex:0 0 220px">
            <label>Max commits to traverse</label>
            <input id="maxCommits" type="text" value="200">
          </div>
        </div>
        <div class="row">
          <button id="startBtn" class="btn primary">Start scan</button>
          <button id="stopBtn" class="btn danger" disabled>Stop</button>
          <button id="exportBtn" class="btn" disabled>Export JSON</button>
        </div>
      </div>

      <div style="margin-top:14px">
        <div class="progressbar"><div id="bar"></div></div>
        <div class="status" style="margin-top:10px">
          <div class="stat"><div class="label">Repos</div><div class="val" id="stat-repos">0</div></div>
          <div class="stat"><div class="label">Files scanned</div><div class="val" id="stat-files">0</div></div>
          <div class="stat"><div class="label">Matches</div><div class="val" id="stat-matches">0</div></div>
          <div class="stat"><div class="label">Rate limit</div><div class="val" id="stat-rate">—</div></div>
        </div>
      </div>
    </section>

    <section class="panel">
      <h2>Patterns</h2>
      <p class="help">Edit as needed. JavaScript RegExp syntax. Each entry is <code>{ name, regex, flags, severity }</code>.</p>
      <textarea id="patterns" rows="22"></textarea>
      <div class="row" style="margin-top:8px">
        <button id="resetPatterns" class="btn">Reset defaults</button>
      </div>
      <p class="footer-note">Tip: Keep the set small to reduce false positives and API usage. Scans text files only; skips large/binary paths.</p>
    </section>
  </div>

  <div class="container">
    <section class="panel">
      <h2>Results</h2>
      <div id="results" class="results"></div>
    </section>
  </div>

  <script>
    // ===== Helpers =====
    const $ = (sel) => document.querySelector(sel);
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));
    const textDecoder = new TextDecoder("utf-8", { fatal:false });
    function human(n){ return Number(n||0).toLocaleString(); }
    function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c])); }
    function looksBinary(uint8){ const len=Math.min(uint8.length,2048); let zeros=0,ctl=0; for(let i=0;i<len;i++){const b=uint8[i]; if(b===0) zeros++; if(b<7 || (b>13 && b<32)) ctl++; } return zeros>0 || ctl/len>0.3; }

    const DEFAULT_PATTERNS = [
      { name: "AWS Access Key ID", regex: "AKIA[0-9A-Z]{16}", flags: "g", severity: "high" },
      { name: "AWS Secret Access Key", regex: "aws(.{0,20})?(secret|access).{0,20}[\"'][0-9a-zA-Z/+]{40}[\"']", flags: "gi", severity: "high" },
      { name: "GitHub Token (classic)", regex: "(?:ghp|gho|ghu|ghs|ghr)_[0-9A-Za-z]{36}", flags: "g", severity: "high" },
      { name: "GitHub Token (fine-grained)", regex: "github_pat_[0-9A-Za-z_]{50,255}", flags: "g", severity: "high" },
      { name: "Google API Key", regex: "AIza[0-9A-Za-z_\\-]{35}", flags: "g", severity: "high" },
      { name: "Slack Token", regex: "xox[baprs]-[0-9A-Za-z-]{10,48}", flags: "g", severity: "high" },
      { name: "Slack Webhook", regex: "https://hooks\\.slack\\.com/services/[A-Za-z0-9/]{20,}", flags: "g", severity: "high" },
      { name: "Private Key Header", regex: "-----BEGIN (?:EC|RSA|OPENSSH|DSA) PRIVATE KEY-----", flags: "g", severity: "critical" },
      { name: "Generic Password Assignments", regex: "\\b(password|passwd|pwd|secret|token)\\b\\s*[:=]\\s*[\"'][^\"'\\n]{6,}[\"']", flags: "gi", severity: "medium" },
      { name: "JWT", regex: "eyJ[A-Za-z0-9_-]{10,}\\.[A-Za-z0-9_-]{10,}\\.[A-Za-z0-9_-]{10,}", flags: "g", severity: "medium" }
    ];

    function compilePatterns(list){ return list.map(p => ({...p, re:new RegExp(p.regex, p.flags||'g')})); }
    function matchFile(content, compiled){
      const lines = content.split(/\r?\n/); const out = [];
      for(let i=0;i<lines.length;i++){
        const line = lines[i];
        for(const p of compiled){ p.re.lastIndex=0; let m; while((m=p.re.exec(line))!==null){ const start=Math.max(0,m.index-60); const end=Math.min(line.length, m.index+(m[0]?.length||0)+60); out.push({ pattern:p.name, severity:p.severity||'medium', line:i+1, match:m[0], snippet: line.slice(start,end)}); if(!p.re.global) break; } }
      }
      return out;
    }

    function renderRateLimit(headers){
      const remain = headers.get('x-ratelimit-remaining');
      const limit = headers.get('x-ratelimit-limit');
      const reset = headers.get('x-ratelimit-reset');
      let extra=''; if(reset){ const d=new Date(parseInt(reset,10)*1000); extra = ` (resets ${d.toLocaleTimeString()})`; }
      $("#stat-rate").textContent = (remain && limit) ? `${remain}/${limit}${extra}` : '—';
    }

    // ===== GitHub API client =====
    function githubClient(token, signal){
      const base='https://api.github.com';
      const headersBase = { 'Accept':'application/vnd.github+json', ...(token?{'Authorization':`Bearer ${token}`}:{}) };
      let queue = Promise.resolve();
      const delayMs = token ? 80 : 150; // go slower without token
      async function request(path, init={}){
        await (queue = queue.then(()=>sleep(delayMs)));
        const res = await fetch(base+path, { ...init, headers:{...headersBase, ...(init.headers||{})}, signal });
        renderRateLimit(res.headers);
        if(!res.ok){ const text = await res.text(); throw new Error(`GitHub API ${res.status}: ${text.slice(0,200)}`); }
        const json = await res.json();
        return { json, headers:res.headers };
      }
      async function paged(path){
        let url=path, out=[], headers;
        while(url){
          const res = await request(url); headers=res.headers; out=out.concat(res.json);
          const link=headers.get('link');
          if(link && link.includes('rel="next"')){ const m=link.match(/<([^>]+)>; rel="next"/); url = m? m[1].replace(base,''): null; } else url=null;
        }
        return { items: out, headers };
      }
      return { request, paged };
    }

    // ===== UI state =====
    let abortController = null;

    async function startScan(){
      const token = $("#token").value.trim(); // optional
      const username = $("#username").value.trim();
      const maxSizeKB = Math.max(1, parseInt($("#maxSizeKB").value,10) || 512);
      const includePrivate = $("#includePrivate").checked && !!token; // needs token
      const includeForks = $("#includeForks").checked;
      const includeArchived = $("#includeArchived").checked;
      const respectGitignore = $("#respectGitignore").checked;
      const scanHistory = $("#scanHistory").checked;
      const maxCommits = Math.max(1, parseInt($("#maxCommits").value,10) || 200);

      if(!username){ alert('Username is required.'); return; }
      if(!token && includePrivate){ alert('Private repo scanning requires a token.'); return; }

      let patterns;
      try{ patterns = JSON.parse($("#patterns").value); if(!Array.isArray(patterns)) throw new Error('Patterns must be an array'); }
      catch(e){ alert('Patterns JSON is invalid. '+e.message); return; }
      const compiled = compilePatterns(patterns);

      // reset UI
      $("#results").innerHTML=''; $("#stat-repos").textContent='0'; $("#stat-files").textContent='0'; $("#stat-matches").textContent='0'; $("#bar").style.width='0%';
      abortController = new AbortController(); const signal = abortController.signal; $("#startBtn").disabled=true; $("#stopBtn").disabled=false; $("#exportBtn").disabled=true;

      const client = githubClient(token, signal);
      try{
        // Identity guard: if token present, enforce token owner === username
        let login = username;
        if(token){ const me = await client.request('/user'); login = me.json.login; if(!login || login.toLowerCase()!==username.toLowerCase()){ throw new Error(`For safety, token user is "${login}", but target username is "${username}".`);} }
        else{ addInfoCard('Public-only mode (no token). Private repos are skipped; rate limit ~60/hour. Please scan only repos you own or have permission to audit.'); }

        // Load repos
        let repos=[];
        if(token){
          const vis = includePrivate ? 'all' : 'public';
          const { items } = await client.paged(`/user/repos?per_page=100&affiliation=owner&visibility=${vis}&sort=updated`);
          repos = items.filter(r => r.owner?.login?.toLowerCase() === login.toLowerCase());
        } else {
          const { items } = await client.paged(`/users/${encodeURIComponent(username)}/repos?type=owner&per_page=100&sort=updated`);
          repos = items;
        }
        const filtered = repos.filter(r => (includeForks || !r.fork) && (includeArchived || !r.archived));
        $("#stat-repos").textContent = human(filtered.length);

        const DEFAULT_IGNORE_DIRS = ["node_modules/","vendor/","dist/","build/","target/",".next/",".git/",".cache/","__pycache__/","venv/",".venv/",".gradle/",".idea/"];
        const IGNORE_DIRS = respectGitignore ? DEFAULT_IGNORE_DIRS : [];

        const jobs = []; let totalFiles=0;

        if(!scanHistory){
          // Current HEAD only
          for(const repo of filtered){
            const branch = repo.default_branch || 'main';
            const { json: treeRes } = await client.request(`/repos/${repo.owner.login}/${repo.name}/git/trees/${encodeURIComponent(branch)}?recursive=1`);
            const tree = treeRes.tree || [];
            if(treeRes.truncated) addInfoCard(`${repo.full_name}: tree was truncated by GitHub API; scan may be partial.`);
            const files = tree.filter(e => e.type==='blob');
            for(const f of files){ if(IGNORE_DIRS.some(d => f.path.startsWith(d))) continue; if(typeof f.size==='number' && f.size > (maxSizeKB*1024)) continue; totalFiles++; jobs.push(() => scanBlobByPath(client, repo, branch, f.path, compiled)); }
          }
        } else {
          // History scan: traverse commits on default branch; dedupe blobs
          const scannedBlobShas = new Set();
          for(const repo of filtered){
            const branch = repo.default_branch || 'main';
            const { items: commits } = await client.paged(`/repos/${repo.owner.login}/${repo.name}/commits?sha=${encodeURIComponent(branch)}&per_page=100`);
            const subset = commits.slice(0, maxCommits);
            for(const c of subset){ const treeSha = c.commit?.tree?.sha; if(!treeSha) continue; const { json: treeRes } = await client.request(`/repos/${repo.owner.login}/${repo.name}/git/trees/${treeSha}?recursive=1`); const tree = treeRes.tree || []; for(const e of tree){ if(e.type!== 'blob') continue; if(IGNORE_DIRS.some(d => e.path.startsWith(d))) continue; if(scannedBlobShas.has(e.sha)) continue; scannedBlobShas.add(e.sha); totalFiles++; jobs.push(() => scanBlobBySha(client, repo, branch, e, compiled, maxSizeKB)); } }
          }
        }

        // Process with limited concurrency
        const CONCURRENCY = token ? 3 : 1;
        let inFlight=0, idx=0, filesDone=0, allMatches=[];
        async function runNext(){ if(signal.aborted) return; if(idx>=jobs.length) return; const i=idx++; inFlight++; try{ const res = await jobs[i](); filesDone++; $("#stat-files").textContent=human(filesDone); const pct = totalFiles? Math.round((filesDone/totalFiles)*100):0; $("#bar").style.width=`${pct}%`; if(res && res.length){ allMatches=allMatches.concat(res); $("#stat-matches").textContent=human(allMatches.length); for(const m of res) addMatchCard(m); } } catch(e){ addErrorCard(e.message);} finally{ inFlight--; if(idx<jobs.length) runNext(); } }
        const starters = Math.min(CONCURRENCY, jobs.length); for(let i=0;i<starters;i++) runNext();
        while((idx<jobs.length || inFlight>0) && !signal.aborted){ await sleep(120); }
        if(!signal.aborted){ $("#exportBtn").disabled=false; $("#exportBtn").onclick = ()=> exportJSON(allMatches); }
      } catch(err){ addErrorCard(err.message || String(err)); }
      finally{ $("#startBtn").disabled=false; $("#stopBtn").disabled=true; }
    }

    async function scanBlobByPath(client, repo, branch, path, compiled){
      try{
        const { json:file } = await client.request(`/repos/${repo.owner.login}/${repo.name}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch)}`);
        if(!file || file.type!=='file' || !file.content) return [];
        const raw = atob(file.content.replace(/\n/g,'')); const uint8 = new Uint8Array(raw.length); for(let i=0;i<raw.length;i++) uint8[i]=raw.charCodeAt(i);
        if(looksBinary(uint8)) return [];
        const text = textDecoder.decode(uint8);
        return matchFile(text, compiled).map(m => ({ repo:`${repo.owner.login}/${repo.name}`, branch, path, html_url:`https://github.com/${repo.owner.login}/${repo.name}/blob/${encodeURIComponent(branch)}/${path}#L${m.line}`, ...m }));
      }catch(e){ addErrorCard(e.message); return []; }
    }

    async function scanBlobBySha(client, repo, branch, entry, compiled, maxSizeKB){
      try{
        const { json: blob } = await client.request(`/repos/${repo.owner.login}/${repo.name}/git/blobs/${entry.sha}`);
        const size = blob.size || 0; if(size > (maxSizeKB*1024)) return [];
        const raw = atob(blob.content.replace(/\n/g,'')); const uint8 = new Uint8Array(raw.length); for(let i=0;i<raw.length;i++) uint8[i]=raw.charCodeAt(i);
        if(looksBinary(uint8)) return [];
        const text = textDecoder.decode(uint8);
        return matchFile(text, compiled).map(m => ({ repo:`${repo.owner.login}/${repo.name}`, branch, path: entry.path, html_url:`https://github.com/${repo.owner.login}/${repo.name}/blob/${encodeURIComponent(branch)}/${entry.path}#L${m.line}`, ...m }));
      }catch(e){ addErrorCard(e.message); return []; }
    }

    function stopScan(){ if(abortController) abortController.abort(); }
    function addInfoCard(message){ const el=document.createElement('div'); el.className='match'; el.innerHTML = `<div class="hdr"><span class="badge">info</span><span>${escapeHtml(message)}</span></div>`; $("#results").prepend(el); }
    function addMatchCard(m){ const el=document.createElement('div'); el.className='match'; const sev = m.severity==='critical'?'crit':(m.severity==='high'?'warn':''); el.innerHTML = `<div class="hdr"><span class="badge ${sev}">${m.severity||'medium'}</span><span class="badge">${escapeHtml(m.pattern)}</span><a class="badge" href="${m.html_url}" target="_blank" rel="noopener">${escapeHtml(m.repo)} → ${escapeHtml(m.path)} :${m.line}</a></div><pre><code>${highlightSnippet(m.snippet, m.match)}</code></pre>`; $("#results").prepend(el); }
    function addErrorCard(message){ const el=document.createElement('div'); el.className='match'; el.innerHTML = `<div class="hdr"><span class="badge crit">error</span><span>${escapeHtml(message)}</span></div>`; $("#results").prepend(el); }
    function exportJSON(matches){ const blob=new Blob([JSON.stringify({ generatedAt:new Date().toISOString(), matches }, null, 2)],{type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`github-secret-scan-${Date.now()}.json`; a.click(); URL.revokeObjectURL(url); }
    function highlightSnippet(snippet, match){ const safe=escapeHtml(snippet); const m=escapeHtml(match); return safe.replace(m, `<mark>${m}</mark>`); }

    // Wire up
    $("#resetPatterns").onclick = ()=> $("#patterns").value = JSON.stringify(DEFAULT_PATTERNS, null, 2);
    $("#startBtn").onclick = (e)=>{ e.preventDefault(); startScan(); };
    $("#stopBtn").onclick = (e)=>{ e.preventDefault(); stopScan(); };
    // Seed defaults on first load
    $("#patterns").value = JSON.stringify(DEFAULT_PATTERNS, null, 2);
  </script>
</body>
</html>
